package Ex03.copy;

import chap06_07.Ex04.A;

// 기본 생성자 : Class A 는 기본생성자가 생략되어 있다.
// 일반적으로 클라스 블락에 1. 필드, 2. 생성자, 3.메소드 형식으로 작성한다.


class A{
	 int m;			// 필드 : 클래스 블럭에 선언된 변수 : 데이터 타입 변수명
	 				// Heap영역에 저장, 객체화 시켜야 사용가능, 예외 : Static 
	 				// 힙 영역의 RAM에는 반드시 초기값이 들어가야 한다.
	 
	//  A () {}		// <== 기본 생성자 : 클래스 이름과 동일하면서 리턴타입이 없는 메소드를 생성자라 호칭한다.
	 				// 기본 생성자는 생략 가능.
	 				// 기본 생성자는 매개변수도 없고, 실행부도 가지지 않는 생성자
	 
	 
	 void work() {	// 메소드 : 리턴타입 메소드명(인풋 매개변수) { 실행부 }
		 			// 메소드는 호출 : work() 
		 
		 System.out.println(m); //0  		 // m : 메모리에 값을 가지고옴. 
	 }
	 
	 
}

class B {
	int m;		// m 은 heap 영역에 저장이 되고, 기본값으로 0을 출력
	
	B() {} // 기본 생성자는 생략 가능하다. 객체의 필드의 초기값을 기본값으로 출력
	
	void work() {
		System.out.println(m); // 0 	메모리의 초기값을 0 으로 출력
		
		
		
	}
}

//객체 생성시 생성자를 통해서 필드의 초기값을 할당하고 갹체 생성 , 

class C {
	int m ;
	
	// C () {} // 기본 생성자는 생략됨, 다른생성자가 존재하는 경우 외부에서 기본생성자 호출시 오류발생
	
	
	C ( int c){		// 생성자의 인풋 값을 받아서 메모리의 기본값으로 로드 m변수의 값을 로드시킨다.
		m = c ; 	// 기본생성자는 생략가능 // 외부에서 호출할 경우  기본 생성자는 생략되면 안된다. () {} 가 생략 불가능.
	}
	
	
	void work () {
		System.out.println(m); 			// m 은 객체를 생성시 생성자에 정수 값을 넣어서 필드 m 을 초기화 시켜줌
	}
}

class D {
	int m, n , l ; 
	
	D () {} 		//기본 생성자
	D (int m , int n ){		// 매개변수가 2개
		this.m=m;			// this는 자기 자신의 객체, 지역변수가 아닌 필드의 변수를 알려줌.
		this.n=n;

	}
	
	D (int a, int b, int c){	// 매개변수가 3개인 생성자
		m = a;
		n = b;
		l = c;
	}
	
	void work() {			// work() 를 호출시 각각의 메모리의 값을 출력
		System.out.println("m : " + m + ",n : " + n + " , l : " + l );
	}
}





public class DefaultConstructor {

	public static void main(String[] args) {
		
		//  클래스 내에 포함될 수 있는 것 : 1. 필드 { }, 2. 메소드 , 3. 생성자, 4.이너 클래스(innerClass)  
		//  생성자의 2가지 특징 : 1. 클래스 이름과 동일한 이름을 가진 메소드를 생성자라 한다.
						//	 2. 생성자는 반환 타입이 없다. ( 메소드는 반환 타입이 있다.) 
		
		//생성자를 사용하는 이유 : 객체를 생성할때 필드의 값을 초기화 하면서 객체를 생성하고자 할때 사용.
			// 객체 클래스 내에서 필드의 초기 값은 일반적으로 할당하지 않는다. 
			// 클래스의 객체를 생성할때 초기값을 할당하면서 객체를 생성할때 
		
		// 객체를 생성할때, 반드시 생성자를 호출 , A a = new A();   <== 객체 생성 구문  
		
		// 기본 생성자 ( default Constructor) : 
				// 인풋 매개변수가 없는 생성자 , 실행부의 값도 비어있는 상태의 생성자.
				// 기본 생성자는 생략 가능 하다.
				// 생략되어 있을 경우, 컴파일러가 자동으로 생성해서 컴파일. 
				// 클래스 내의 기본 생성자 이외의 다른 생성자가 존재하는 경우 , 기본 생성자 호출시 생략되면 안된다.
				// 
				
				A a = new A();		// A() : 기본생성자 호출, << 생성자 생략됨>>, 컴파일러가 기본 생성자를 할당해줌.
									// 객체생성시 반드시 생성자를 호출해야 된다.
				a.work();	//0   << 메모리값 출력
				
				B b = new B();	// <<<기본 생성자 호출>>>
				
				b.work();  	//0 객체의 초기값 출력
				
				C c = new C(3);			// 생성자 호출시 기본값을 호출해서 메모리 필드에 초기값 구성
				
				c.work();			//메모리출력 work();
				
				C cc = new C(5);
				
				cc.work();
				
				
				
				C ccc = new C(10 + 10);
				ccc.work(); 
				
				// Class C 는 기본생성자가 생략되있다. // C () {}
				// Class C 는 인풋 매개 변수가 하나인 생성자가 존재
				
			// cccc new C(); // 오류발생	: 기본생성자가 생략, 다른 생성자자가 존재, <기본생성자 호출>
			//	cccc.work();
				
				D d = new D(); 		// 기본 생성자 호출, 객체의 필드의 초기값 (m : 0, n : 0, l : 0)
				d.work(); 			// 
				
				D dd = new D (3, 4, 5 );	//매개변수가 정수 3개인 생성자 호출
				dd.work(); 
				
				D ddd = new D(1,2); // 매개변수가 정수 3개인 생성자를 호출
				ddd.work();
				
				//생성자 : 메소드 이름이 객체의 이름과 동일하고 리턴값(void)이 없는 메소드.
				// 객체 내의 필드의 값을 초기화 할때 오버로딩 (Overloading)에 의해서 해당 생성자가 호출 
					// 오버로딩 : 메소드명(생성자명 , 데이터 타입, 매개변수 갯수) 	<== 식별자 signature 시그니쳐
						// 오류가 발생 되는 경우 : 동일한 데이터 타입 과 갯수가 동일한 경우, 
				
				
				
				
				
				
	}
	
}
